<!DOCTYPE html>

<title>Fetch + Streams Demo</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link href="https://resources.whatwg.org/logo-streams.svg" rel="icon">

<style>
    * { box-sizing: border-box; }

    html { font-family: Calibri, Helvetica, Arial; }

    h1 { text-align: center; }

    form {
        max-width: 500px;
        margin: 0 auto;
        text-align: center;
    }

    label, input, output { display: block; }
    input[type="text"] { width: 100%; margin: 0.5em 0; }
    input[type="submit"] { display: inline; }

    label { margin: 2em auto; padding: 1em; background-color: #efe; }
    output { font-family: monospace; margin: 0.5em 0; min-height: 30px; }

    #output { margin-top: 2em; }

    footer { font-size: smaller; border-top: 1px solid #3C790A; text-align: center; margin-top: 2em; }
</style>

<h1>Fetch + Streams Demo</h1>

<p>This demo will search the first billion digits of PI for a substring you specify, and tell you the position at which it was found. It will do this without consuming a billion bytes of memory! That was impossible with XHR!

<p>Furthermore, it won't even need to do text decoding and string comparison, as it will operate on the bytes directly. (XHR's pseudo-streaming mode, with an ever-growing <code>responseText</code> you could poll, was text-only.)

<p>Finally, once it finds the substring, it will cancel the stream, preventing further network usage! Canceling a fetch was not previously possible. (It is not yet possible to cancel before the headers arrive; see <a href="https://github.com/slightlyoff/ServiceWorker/issues/592">slightlyoff/ServiceWorker#592</a> and linked issues.)


<form id="form">
    <label>
        Enter a substring to search for (bytes displayed below)
        <input type="text" id="substring" pattern="[0-9]+" title="Enter only digits" required>
        <output id="bytes" for="substring"></output>

        <input type="radio" name="impl" id="impl_async" value="async" checked> Async-Await<br>
        <input type="radio" name="impl" id="impl_promise" value="promise"> Promise<br>
    </label>

    <input type="submit" value="Search, with the Power of Streams!">

    <fieldset id="output" hidden>
        <progress id="progress"></progress>
        <output id="progress-text"></output>
    </fieldset>
</form>

<footer>
    <p><a href="https://github.com/domenic/streams-demo/blob/gh-pages/index.html">Source code on GitHub</a></p>

    <a href="https://streams.spec.whatwg.org/"><img alt="Streams Logo" src="https://resources.whatwg.org/logo-streams.svg" height="30"></a>
</footer>

<script>
(function () {
    'use strict';

    // const PI_URL = 'http://localhost:8000/pi-billion.txt';
    const PI_URL = 'https://cors-anywhere.herokuapp.com/http://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt';

    const substring = document.querySelector('#substring');
    const bytes = document.querySelector('#bytes');
    const impl_async = document.querySelector('#impl_async');
    const form = document.querySelector('#form');

    const output = document.querySelector('#output');
    const progress = document.querySelector('#progress');
    const progressText = document.querySelector('#progress-text');

    const encoder = new TextEncoder();

    let bytesValue = new Uint8Array();
    substring.addEventListener('input', function () {
        bytesValue = encoder.encode(substring.value);

        const bytesAsStrings = Array.prototype.map.call(bytesValue, function (b) { return `0x${b.toString(16)}`; });
        bytes.value = Array.prototype.join.call(bytesAsStrings, ' ');
    });

    let soFar;
    let contentLength;
    let start;

    form.addEventListener('submit', function (e) {
        e.preventDefault();
        output.removeAttribute('hidden');

        progressText.textContent = 'Performing fetch...';

        fetch(PI_URL).then(function (res) {
            start = Date.now();

            soFar = 0;
            contentLength = res.headers.get('Content-Length');
            progress.max = contentLength;

            if (impl_async.checked) {
              return pumpAsync(res.body.getReader());
            } else {
              return pumpPromise(res.body.getReader());
            }
        })
        .catch(function (e) {
            progressText.textContent = e;
        });
    });

    async function pumpAsync(reader) {
        var result = await reader.read();

        if (result.done) {
            progressText.textContent = `All done! (${soFar} bytes total)`;
            return;
        }

        const chunk = result.value;

        soFar += chunk.byteLength;
        updateProgress();

        let found = -1;
        for (let i = 0; i < chunk.length; ++i) {
            if (chunk[i] === bytesValue[0]) {
                found = i;
                for (let j = 1; j < bytesValue.length; ++j) {
                    if (chunk[i + j] !== bytesValue[j]) {
                        found = -1;
                        break;
                    }
                }
            }

            if (found !== -1) {
                break;
            }
        }

        if (found !== -1) {
            let end = Date.now();
            progressText.textContent = `Found it with async-await! At position ${soFar - chunk.byteLength + found}, took ${end - start} ms.`;

            return reader.cancel();
        } else {
            return pumpAsync(reader);
        }
    }

    function pumpPromise(reader) {
        return reader.read().then(function (result) {
            if (result.done) {
                progressText.textContent = `All done! (${soFar} bytes total)`;
                return;
            }

            const chunk = result.value;

            soFar += chunk.byteLength;
            updateProgress();

            let found = -1;
            for (let i = 0; i < chunk.length; ++i) {
                if (chunk[i] === bytesValue[0]) {
                    found = i;
                    for (let j = 1; j < bytesValue.length; ++j) {
                        if (chunk[i + j] !== bytesValue[j]) {
                            found = -1;
                            break;
                        }
                    }
                }

                if (found !== -1) {
                    break;
                }
            }

            if (found !== -1) {
                let end = Date.now();
                progressText.textContent = `Found it with promises! At position ${soFar - chunk.byteLength + found}, took ${end - start} ms.`;

                return reader.cancel();
            } else {
                return pumpPromise(reader);
            }
        });
    }

    function updateProgress() {
        progressText.textContent = contentLength ?
            `${soFar}/${contentLength} bytes received` : `${soFar} bytes received`;
        progress.value = contentLength ? soFar : null;
    }
}());
</script>
